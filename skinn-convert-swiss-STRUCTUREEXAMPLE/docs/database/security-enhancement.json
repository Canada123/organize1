{
  "specification_id": "SKIIN-SEC-ENH-001",
  "version": "1.0",
  "created": "2025-08-22",
  "updated": "2025-08-22",
  "status": "ready_for_implementation",
  "
  
  "title": "Database Security Enhancement Specification for Eligibility Questionnaire",
  
  "feature_description": {
    "summary": "Comprehensive security enhancements for the SKIIN eligibility questionnaire database, focusing on OTP security hardening, advanced RLS policies, Swiss healthcare compliance, and performance optimization",
    "scope": "Enhanced schema design for secure multi-step eligibility form with Swiss insurance integration",
    "target_audience": "supabase-implementation-engineer"
  },

  "current_schema_analysis": {
    "existing_tables": {
      "count": 14,
      "core_user_tables": [
        "user_profiles",
        "eligibility_questionnaires", 
        "questionnaire_responses",
        "conditions",
        "gdpr_requests"
      ],
      "swiss_insurance_tables": [
        "insurance_providers",
        "insurance_models",
        "user_insurance",
        "gp_referrals",
        "payments",
        "analytics_events",
        "feature_flags"
      ],
      "security_tables": [
        "otp_verifications",
        "rate_limits",
        "suspicious_activities"
      ]
    },
    "current_rls_status": "Basic RLS enabled with user-specific and service_role policies",
    "security_gaps": [
      "OTP verification lacks comprehensive rate limiting",
      "Missing cross-table security relationships",
      "No audit trail for sensitive operations",
      "Insufficient encryption specifications",
      "No multi-factor authentication support"
    ]
  },

  "schema_enhancements": {
    "1_session_management": {
      "description": "Enhanced session management for multi-step questionnaire",
      "declarative_sql": "-- Enhanced session management table\nCREATE TABLE IF NOT EXISTS public.questionnaire_sessions (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n    session_token TEXT UNIQUE NOT NULL,\n    \n    -- Session state\n    current_step INTEGER DEFAULT 0,\n    total_steps INTEGER DEFAULT 5,\n    completion_percentage DECIMAL(5,2) DEFAULT 0.00,\n    session_data JSONB DEFAULT '{}',\n    \n    -- Security tracking\n    ip_address INET,\n    user_agent TEXT,\n    device_fingerprint TEXT,\n    last_activity_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    \n    -- Session lifecycle\n    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    expires_at TIMESTAMPTZ DEFAULT (CURRENT_TIMESTAMP + INTERVAL '24 hours'),\n    completed_at TIMESTAMPTZ,\n    abandoned_at TIMESTAMPTZ,\n    \n    -- Security flags\n    is_verified BOOLEAN DEFAULT FALSE,\n    requires_otp BOOLEAN DEFAULT TRUE,\n    security_level TEXT DEFAULT 'standard' CHECK (security_level IN ('standard', 'enhanced', 'maximum')),\n    \n    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP\n);",
      "indexes": [\n        "CREATE INDEX idx_sessions_user ON public.questionnaire_sessions(user_id);",\n        "CREATE INDEX idx_sessions_token ON public.questionnaire_sessions(session_token);",\n        "CREATE INDEX idx_sessions_active ON public.questionnaire_sessions(last_activity_at) WHERE completed_at IS NULL;",\n        "CREATE INDEX idx_sessions_expires ON public.questionnaire_sessions(expires_at) WHERE expires_at > CURRENT_TIMESTAMP;"\n      ],
      "triggers": [\n        "CREATE TRIGGER update_sessions_updated_at BEFORE UPDATE ON public.questionnaire_sessions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();"\n      ]
    },

    "2_enhanced_otp_security": {
      "description": "Hardened OTP system with comprehensive security features",
      "declarative_sql": "-- Enhanced OTP verification table (replaces existing)\nDROP TABLE IF EXISTS public.otp_verifications CASCADE;\n\nCREATE TABLE public.otp_verifications (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n    session_id UUID REFERENCES public.questionnaire_sessions(id) ON DELETE CASCADE,\n    \n    -- Contact information\n    email TEXT,\n    phone TEXT,\n    \n    -- OTP security\n    otp_hash TEXT NOT NULL, -- bcrypt hash with cost factor 12\n    otp_type TEXT NOT NULL CHECK (otp_type IN ('email', 'phone', 'backup')),\n    purpose TEXT NOT NULL CHECK (purpose IN ('signup', 'login', 'verification', 'password_reset', 'session_verify')),\n    \n    -- Rate limiting and security\n    attempts INTEGER DEFAULT 0,\n    max_attempts INTEGER DEFAULT 3,\n    locked_until TIMESTAMPTZ,\n    \n    -- Device tracking\n    ip_address INET NOT NULL,\n    user_agent TEXT,\n    device_fingerprint TEXT,\n    geolocation JSONB, -- Country, region for anomaly detection\n    \n    -- Timing and lifecycle\n    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    expires_at TIMESTAMPTZ DEFAULT (CURRENT_TIMESTAMP + INTERVAL '10 minutes'),\n    verified_at TIMESTAMPTZ,\n    invalidated_at TIMESTAMPTZ,\n    \n    -- Audit trail\n    verification_method TEXT, -- 'manual_entry', 'auto_fill', 'voice_call'\n    client_info JSONB DEFAULT '{}',\n    \n    -- Security metadata\n    risk_score INTEGER DEFAULT 0 CHECK (risk_score >= 0 AND risk_score <= 100),\n    security_flags TEXT[] DEFAULT ARRAY[]::TEXT[],\n    \n    CONSTRAINT valid_contact_otp CHECK (email IS NOT NULL OR phone IS NOT NULL)\n);",
      "indexes": [\n        "CREATE INDEX idx_otp_email_active ON public.otp_verifications(email) WHERE email IS NOT NULL AND verified_at IS NULL;",\n        "CREATE INDEX idx_otp_phone_active ON public.otp_verifications(phone) WHERE phone IS NOT NULL AND verified_at IS NULL;",\n        "CREATE INDEX idx_otp_expires_active ON public.otp_verifications(expires_at) WHERE verified_at IS NULL AND expires_at > CURRENT_TIMESTAMP;",\n        "CREATE INDEX idx_otp_ip_recent ON public.otp_verifications(ip_address, created_at DESC);",\n        "CREATE INDEX idx_otp_user_session ON public.otp_verifications(user_id, session_id);",\n        "CREATE INDEX idx_otp_risk_score ON public.otp_verifications(risk_score DESC) WHERE risk_score > 50;"\n      ]
    },

    "3_comprehensive_audit_trail": {
      "description": "Complete audit logging for all sensitive operations",
      "declarative_sql": "-- Comprehensive audit trail table\nCREATE TABLE IF NOT EXISTS public.audit_logs (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    \n    -- Event identification\n    event_type TEXT NOT NULL, -- 'otp_generated', 'otp_verified', 'data_access', 'data_modification'\n    table_name TEXT NOT NULL,\n    record_id UUID,\n    \n    -- User context\n    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,\n    session_id UUID REFERENCES public.questionnaire_sessions(id) ON DELETE SET NULL,\n    \n    -- Action details\n    action TEXT NOT NULL, -- 'CREATE', 'READ', 'UPDATE', 'DELETE', 'VERIFY', 'LOCK'\n    old_values JSONB,\n    new_values JSONB,\n    changes JSONB,\n    \n    -- Security context\n    ip_address INET,\n    user_agent TEXT,\n    device_fingerprint TEXT,\n    \n    -- Risk assessment\n    risk_level TEXT CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),\n    security_flags TEXT[] DEFAULT ARRAY[]::TEXT[],\n    \n    -- Compliance\n    gdpr_category TEXT, -- 'personal_data', 'health_data', 'financial_data'\n    retention_period INTERVAL DEFAULT '7 years',\n    \n    -- Timing\n    occurred_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    processed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    \n    -- Additional metadata\n    metadata JSONB DEFAULT '{}'\n);",
      "indexes": [\n        "CREATE INDEX idx_audit_user_time ON public.audit_logs(user_id, occurred_at DESC);",\n        "CREATE INDEX idx_audit_table_record ON public.audit_logs(table_name, record_id);",\n        "CREATE INDEX idx_audit_event_type ON public.audit_logs(event_type, occurred_at DESC);",\n        "CREATE INDEX idx_audit_risk_level ON public.audit_logs(risk_level, occurred_at DESC) WHERE risk_level IN ('high', 'critical');",\n        "CREATE INDEX idx_audit_ip_time ON public.audit_logs(ip_address, occurred_at DESC);",\n        "CREATE INDEX idx_audit_gdpr ON public.audit_logs(gdpr_category, user_id) WHERE gdpr_category IS NOT NULL;"\n      ]
    },

    "4_device_management": {
      "description": "Device registration and management for enhanced security",
      "declarative_sql": "-- Device management for security tracking\nCREATE TABLE IF NOT EXISTS public.user_devices (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n    \n    -- Device identification\n    device_fingerprint TEXT NOT NULL,\n    device_name TEXT,\n    device_type TEXT CHECK (device_type IN ('mobile', 'tablet', 'desktop', 'unknown')),\n    \n    -- Browser/OS info\n    browser_name TEXT,\n    browser_version TEXT,\n    os_name TEXT,\n    os_version TEXT,\n    \n    -- Trust level\n    trust_level TEXT DEFAULT 'unknown' CHECK (trust_level IN ('trusted', 'known', 'unknown', 'suspicious')),\n    is_primary BOOLEAN DEFAULT FALSE,\n    \n    -- Usage tracking\n    first_seen_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    last_seen_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    last_ip_address INET,\n    usage_count INTEGER DEFAULT 1,\n    \n    -- Security flags\n    is_blocked BOOLEAN DEFAULT FALSE,\n    blocked_reason TEXT,\n    blocked_until TIMESTAMPTZ,\n    \n    -- Location tracking (anonymized)\n    last_country TEXT,\n    last_region TEXT,\n    \n    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP\n);",
      "indexes": [\n        "CREATE INDEX idx_devices_user ON public.user_devices(user_id);",\n        "CREATE INDEX idx_devices_fingerprint ON public.user_devices(device_fingerprint);",\n        "CREATE INDEX idx_devices_blocked ON public.user_devices(is_blocked) WHERE is_blocked = TRUE;",\n        "CREATE INDEX idx_devices_trust ON public.user_devices(trust_level, last_seen_at DESC);",\n        "CREATE UNIQUE INDEX idx_devices_user_fingerprint ON public.user_devices(user_id, device_fingerprint);"\n      ]
    },

    "5_swiss_compliance_enhancements": {
      "description": "Enhanced tables for Swiss healthcare data compliance",
      "declarative_sql": "-- Swiss healthcare compliance tracking\nCREATE TABLE IF NOT EXISTS public.swiss_compliance_logs (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n    questionnaire_id UUID REFERENCES public.eligibility_questionnaires(id) ON DELETE CASCADE,\n    \n    -- Compliance type\n    compliance_type TEXT NOT NULL CHECK (compliance_type IN (\n        'gdpr_consent', 'medical_data_consent', 'insurance_verification',\n        'gp_referral', 'data_retention', 'data_deletion'\n    )),\n    \n    -- Consent details\n    consent_version TEXT NOT NULL,\n    consent_text TEXT,\n    consent_given BOOLEAN DEFAULT FALSE,\n    consent_method TEXT CHECK (consent_method IN ('digital_signature', 'checkbox', 'email_confirmation')),\n    \n    -- Legal basis\n    legal_basis TEXT CHECK (legal_basis IN (\n        'consent', 'contract', 'legal_obligation', 'vital_interests',\n        'public_task', 'legitimate_interests'\n    )),\n    \n    -- Swiss specific\n    swiss_canton TEXT CHECK (swiss_canton IN (\n        'AG', 'AI', 'AR', 'BE', 'BL', 'BS', 'FR', 'GE', 'GL', 'GR',\n        'JU', 'LU', 'NE', 'NW', 'OW', 'SG', 'SH', 'SO', 'SZ', 'TG',\n        'TI', 'UR', 'VD', 'VS', 'ZG', 'ZH'\n    )),\n    insurance_law_compliance BOOLEAN DEFAULT TRUE,\n    \n    -- Timing\n    granted_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    expires_at TIMESTAMPTZ,\n    revoked_at TIMESTAMPTZ,\n    \n    -- Audit\n    ip_address INET,\n    user_agent TEXT,\n    \n    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP\n);"
    }
  },

  "enhanced_rls_policies": {
    "1_session_policies": {
      "description": "Row-level security for questionnaire sessions",
      "policies": [
        {
          "name": "session_user_access",
          "sql": "CREATE POLICY \"Users can only access their own sessions\" ON public.questionnaire_sessions FOR ALL USING (auth.uid() = user_id);"
        },
        {
          "name": "session_service_access", 
          "sql": "CREATE POLICY \"Service role full access to sessions\" ON public.questionnaire_sessions FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');"
        },
        {
          "name": "session_anonymous_create",
          "sql": "CREATE POLICY \"Anonymous users can create sessions\" ON public.questionnaire_sessions FOR INSERT WITH CHECK (auth.role() = 'anon' AND user_id IS NULL);"
        }
      ]
    },

    "2_otp_enhanced_policies": {
      "description": "Enhanced RLS for OTP verification with performance optimization",
      "policies": [
        {
          "name": "otp_user_verification_access",
          "sql": "CREATE POLICY \"Users can verify their own OTPs\" ON public.otp_verifications FOR SELECT USING (\n    auth.uid() = user_id OR \n    (auth.role() = 'anon' AND session_id IN (\n        SELECT id FROM public.questionnaire_sessions \n        WHERE session_token = current_setting('app.current_session_token', true)\n    ))\n);"
        },
        {
          "name": "otp_system_generation",
          "sql": "CREATE POLICY \"System can generate OTPs\" ON public.otp_verifications FOR INSERT WITH CHECK (\n    auth.jwt() ->> 'role' = 'service_role' OR\n    (auth.role() = 'authenticated' AND auth.uid() = user_id)\n);"
        },
        {
          "name": "otp_verification_update",
          "sql": "CREATE POLICY \"Users can update verification status\" ON public.otp_verifications FOR UPDATE USING (\n    auth.uid() = user_id AND verified_at IS NULL AND expires_at > CURRENT_TIMESTAMP\n) WITH CHECK (\n    verified_at IS NOT NULL OR attempts < max_attempts\n);"
        }
      ]
    },

    "3_audit_access_policies": {
      "description": "Strict access control for audit logs",
      "policies": [
        {
          "name": "audit_log_read_own",
          "sql": "CREATE POLICY \"Users can read their own audit logs\" ON public.audit_logs FOR SELECT USING (\n    auth.uid() = user_id AND \n    risk_level NOT IN ('high', 'critical')\n);"
        },
        {
          "name": "audit_log_system_full",
          "sql": "CREATE POLICY \"Service role full audit access\" ON public.audit_logs FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');"
        },
        {
          "name": "audit_log_compliance_access",
          "sql": "CREATE POLICY \"Compliance role can read all audit logs\" ON public.audit_logs FOR SELECT USING (\n    auth.jwt() ->> 'role' = 'compliance_officer' OR\n    auth.jwt() ->> 'role' = 'security_admin'\n);"
        }
      ]
    },

    "4_device_security_policies": {
      "description": "Device management access control",
      "policies": [
        {
          "name": "device_user_management",
          "sql": "CREATE POLICY \"Users can manage their own devices\" ON public.user_devices FOR ALL USING (auth.uid() = user_id);"
        },
        {
          "name": "device_security_monitoring",
          "sql": "CREATE POLICY \"Security team can monitor suspicious devices\" ON public.user_devices FOR SELECT USING (\n    auth.jwt() ->> 'role' = 'security_admin' OR\n    (trust_level = 'suspicious' AND auth.jwt() ->> 'role' = 'compliance_officer')\n);"
        }
      ]
    }
  },

  "security_functions": {
    "1_enhanced_otp_generation": {
      "description": "Enhanced OTP generation with comprehensive security",
      "sql": "CREATE OR REPLACE FUNCTION public.generate_secure_otp_v2(\n    p_user_id UUID DEFAULT NULL,\n    p_session_id UUID DEFAULT NULL,\n    p_email TEXT DEFAULT NULL,\n    p_phone TEXT DEFAULT NULL,\n    p_purpose TEXT DEFAULT 'verification',\n    p_ip_address INET DEFAULT NULL,\n    p_user_agent TEXT DEFAULT NULL,\n    p_device_fingerprint TEXT DEFAULT NULL\n)\nRETURNS TABLE(\n    success BOOLEAN,\n    otp_id UUID,\n    otp_code TEXT,\n    expires_at TIMESTAMPTZ,\n    error_message TEXT,\n    risk_score INTEGER\n) AS $$\nDECLARE\n    v_otp_code TEXT;\n    v_otp_hash TEXT;\n    v_otp_id UUID;\n    v_risk_score INTEGER := 0;\n    v_device_trust TEXT;\n    v_rate_limit_exceeded BOOLEAN;\nBEGIN\n    -- Risk assessment\n    SELECT calculate_request_risk(p_ip_address, p_device_fingerprint, p_user_id) INTO v_risk_score;\n    \n    -- Check device trust level\n    SELECT COALESCE(trust_level, 'unknown') INTO v_device_trust\n    FROM public.user_devices \n    WHERE user_id = p_user_id AND device_fingerprint = p_device_fingerprint\n    ORDER BY last_seen_at DESC LIMIT 1;\n    \n    -- Enhanced rate limiting check\n    SELECT check_comprehensive_rate_limits(\n        COALESCE(p_email, p_phone), \n        p_ip_address::TEXT, \n        p_device_fingerprint,\n        'otp_request'\n    ) INTO v_rate_limit_exceeded;\n    \n    IF v_rate_limit_exceeded THEN\n        -- Log suspicious activity\n        INSERT INTO public.suspicious_activities (\n            user_id, ip_address, activity_type, severity, description\n        ) VALUES (\n            p_user_id, p_ip_address, 'rate_limit_exceeded', 'medium',\n            format('Rate limit exceeded for OTP generation')\n        );\n        \n        RETURN QUERY SELECT FALSE, NULL::UUID, NULL::TEXT, NULL::TIMESTAMPTZ, \n            'Rate limit exceeded. Please try again later.'::TEXT, v_risk_score;\n        RETURN;\n    END IF;\n    \n    -- Generate cryptographically secure OTP\n    v_otp_code := generate_crypto_secure_otp(6);\n    v_otp_hash := crypt(v_otp_code, gen_salt('bf', 12));\n    \n    -- Create OTP record with enhanced security\n    INSERT INTO public.otp_verifications (\n        user_id, session_id, email, phone, otp_hash, otp_type, purpose,\n        ip_address, user_agent, device_fingerprint, risk_score\n    ) VALUES (\n        p_user_id, p_session_id, p_email, p_phone, v_otp_hash,\n        CASE WHEN p_email IS NOT NULL THEN 'email' ELSE 'phone' END,\n        p_purpose, p_ip_address, p_user_agent, p_device_fingerprint, v_risk_score\n    ) RETURNING id, expires_at INTO v_otp_id, expires_at;\n    \n    -- Update device trust if first time\n    INSERT INTO public.user_devices (\n        user_id, device_fingerprint, last_ip_address, usage_count\n    ) VALUES (\n        p_user_id, p_device_fingerprint, p_ip_address, 1\n    ) ON CONFLICT (user_id, device_fingerprint) DO UPDATE SET\n        usage_count = user_devices.usage_count + 1,\n        last_seen_at = CURRENT_TIMESTAMP,\n        last_ip_address = p_ip_address;\n    \n    RETURN QUERY SELECT TRUE, v_otp_id, v_otp_code, expires_at, NULL::TEXT, v_risk_score;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER\nSET search_path = public, pg_temp;"
    },

    "2_risk_assessment": {
      "description": "Comprehensive risk assessment for security events",
      "sql": "CREATE OR REPLACE FUNCTION public.calculate_request_risk(\n    p_ip_address INET,\n    p_device_fingerprint TEXT,\n    p_user_id UUID DEFAULT NULL\n)\nRETURNS INTEGER AS $$\nDECLARE\n    v_risk_score INTEGER := 0;\n    v_ip_reputation INTEGER;\n    v_device_trust TEXT;\n    v_location_anomaly BOOLEAN;\nBEGIN\n    -- IP reputation check\n    SELECT CASE \n        WHEN COUNT(*) > 10 THEN 30  -- Many attempts from this IP\n        WHEN COUNT(*) > 5 THEN 15\n        ELSE 0\n    END INTO v_ip_reputation\n    FROM public.suspicious_activities\n    WHERE ip_address = p_ip_address\n    AND occurred_at > CURRENT_TIMESTAMP - INTERVAL '24 hours';\n    \n    v_risk_score := v_risk_score + v_ip_reputation;\n    \n    -- Device trust check\n    IF p_user_id IS NOT NULL THEN\n        SELECT trust_level INTO v_device_trust\n        FROM public.user_devices\n        WHERE user_id = p_user_id AND device_fingerprint = p_device_fingerprint;\n        \n        v_risk_score := v_risk_score + CASE v_device_trust\n            WHEN 'trusted' THEN 0\n            WHEN 'known' THEN 5\n            WHEN 'unknown' THEN 20\n            WHEN 'suspicious' THEN 50\n            ELSE 25\n        END;\n    END IF;\n    \n    -- Time-based anomaly (requests outside normal hours)\n    IF EXTRACT(HOUR FROM CURRENT_TIMESTAMP) NOT BETWEEN 6 AND 23 THEN\n        v_risk_score := v_risk_score + 10;\n    END IF;\n    \n    RETURN GREATEST(0, LEAST(100, v_risk_score));\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;"
    },

    "3_comprehensive_rate_limiting": {
      "description": "Advanced rate limiting with multiple vectors",
      "sql": "CREATE OR REPLACE FUNCTION public.check_comprehensive_rate_limits(\n    p_identifier TEXT,\n    p_ip_address TEXT,\n    p_device_fingerprint TEXT,\n    p_action TEXT\n)\nRETURNS BOOLEAN AS $$\nDECLARE\n    v_identifier_blocked BOOLEAN := FALSE;\n    v_ip_blocked BOOLEAN := FALSE;\n    v_device_blocked BOOLEAN := FALSE;\nBEGIN\n    -- Check identifier-based rate limiting\n    SELECT check_rate_limit(p_identifier, 'identifier', p_action, 3, INTERVAL '15 minutes') \n    INTO v_identifier_blocked;\n    \n    -- Check IP-based rate limiting\n    SELECT check_rate_limit(p_ip_address, 'ip', p_action, 10, INTERVAL '1 hour')\n    INTO v_ip_blocked;\n    \n    -- Check device-based rate limiting\n    SELECT check_rate_limit(p_device_fingerprint, 'device', p_action, 5, INTERVAL '30 minutes')\n    INTO v_device_blocked;\n    \n    RETURN v_identifier_blocked OR v_ip_blocked OR v_device_blocked;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;"
    }
  },

  "migration_strategy": {
    "approach": "declarative_first_with_manual_migrations",
    "phases": [
      {
        "phase": 1,
        "description": "Schema enhancements",
        "migration_file": "012_security_schema_enhancements.sql",
        "declarative_changes": [
          "questionnaire_sessions table creation",
          "enhanced otp_verifications table",
          "audit_logs table creation",
          "user_devices table creation",
          "swiss_compliance_logs table creation"
        ]
      },
      {
        "phase": 2,
        "description": "Security functions deployment",
        "migration_file": "013_security_functions.sql",
        "manual_migration_required": true,
        "reason": "Complex stored procedures with security implications"
      },
      {
        "phase": 3,
        "description": "Enhanced RLS policies",
        "migration_file": "014_enhanced_rls_policies.sql",
        "manual_migration_required": true,
        "reason": "Modifying existing RLS policies requires careful coordination"
      },
      {
        "phase": 4,
        "description": "Data migration and cleanup",
        "migration_file": "015_security_data_migration.sql",
        "manual_migration_required": true,
        "reason": "Migrating existing OTP data and cleaning up obsolete records"
      }
    ]
  },

  "performance_optimization": {
    "1_strategic_indexing": {
      "description": "Performance-optimized indexes for security operations",
      "indexes": [
        {
          "name": "idx_questionnaire_sessions_active_user",
          "sql": "CREATE INDEX CONCURRENTLY idx_questionnaire_sessions_active_user ON public.questionnaire_sessions(user_id, last_activity_at DESC) WHERE completed_at IS NULL;",
          "purpose": "Optimize active session lookups"
        },
        {
          "name": "idx_otp_verifications_active_lookup",
          "sql": "CREATE INDEX CONCURRENTLY idx_otp_verifications_active_lookup ON public.otp_verifications(email, phone, expires_at DESC) WHERE verified_at IS NULL;",
          "purpose": "Fast OTP verification lookups"
        },
        {
          "name": "idx_audit_logs_compliance_search",
          "sql": "CREATE INDEX CONCURRENTLY idx_audit_logs_compliance_search ON public.audit_logs(user_id, gdpr_category, occurred_at DESC) WHERE gdpr_category IS NOT NULL;",
          "purpose": "GDPR compliance queries"
        },
        {
          "name": "idx_rate_limits_active_check",
          "sql": "CREATE INDEX CONCURRENTLY idx_rate_limits_active_check ON public.rate_limits(identifier, action, window_start DESC) WHERE blocked_until IS NULL OR blocked_until > CURRENT_TIMESTAMP;",
          "purpose": "Rate limiting performance"
        }
      ]
    },

    "2_query_optimization": {
      "description": "Optimized queries for common operations",
      "materialized_views": [
        {
          "name": "mv_user_security_summary",
          "sql": "CREATE MATERIALIZED VIEW public.mv_user_security_summary AS\nSELECT \n    u.id as user_id,\n    COUNT(DISTINCT d.id) as trusted_devices,\n    COUNT(DISTINCT o.id) FILTER (WHERE o.created_at > CURRENT_TIMESTAMP - INTERVAL '30 days') as recent_otps,\n    COUNT(DISTINCT s.id) FILTER (WHERE s.severity IN ('high', 'critical')) as security_incidents,\n    MAX(d.last_seen_at) as last_device_activity,\n    AVG(o.risk_score) as avg_risk_score\nFROM auth.users u\nLEFT JOIN public.user_devices d ON d.user_id = u.id\nLEFT JOIN public.otp_verifications o ON o.user_id = u.id\nLEFT JOIN public.suspicious_activities s ON s.user_id = u.id\nGROUP BY u.id;",
          "refresh_schedule": "REFRESH MATERIALIZED VIEW CONCURRENTLY public.mv_user_security_summary;"
        }
      ]
    }
  },

  "swiss_healthcare_compliance": {
    "gdpr_enhancements": {
      "data_classification": [
        "Personal data (email, phone, name)",
        "Health data (symptoms, conditions, medical history)", 
        "Financial data (insurance, payment information)",
        "Sensitive personal data (genetic predisposition)"
      ],
      "retention_policies": {
        "personal_data": "7 years after last interaction",
        "health_data": "10 years per Swiss medical records law",
        "audit_logs": "7 years for compliance",
        "otp_data": "30 days after verification or expiry"
      },
      "consent_management": {
        "required_consents": [
          "Data processing consent (GDPR Article 6)",
          "Health data processing (GDPR Article 9)",
          "Marketing communications (optional)",
          "Data sharing with insurance (required for reimbursement)"
        ]
      }
    },

    "swiss_insurance_integration": {
      "model_specific_requirements": {
        "standard_flex": {
          "gp_referral": "optional",
          "partner_gp_allowed": true,
          "prior_authorization": false
        },
        "hmo_hausarzt": {
          "gp_referral": "required",
          "partner_gp_allowed": false,
          "prior_authorization": true
        },
        "telmed": {
          "gp_referral": "required_via_hotline",
          "partner_gp_allowed": false,
          "prior_authorization": true
        }
      }
    }
  },

  "security_monitoring": {
    "1_alert_thresholds": {
      "critical_alerts": [
        "More than 5 failed OTP attempts from same IP in 1 hour",
        "User account with >10 suspicious activities in 24 hours",
        "OTP verification from new country/region",
        "Multiple users from same suspicious IP"
      ],
      "monitoring_queries": [
        {
          "name": "suspicious_otp_activity",
          "sql": "SELECT ip_address, COUNT(*) as failed_attempts, array_agg(DISTINCT email) as affected_emails FROM public.otp_verifications WHERE verified_at IS NULL AND attempts >= max_attempts AND created_at > CURRENT_TIMESTAMP - INTERVAL '1 hour' GROUP BY ip_address HAVING COUNT(*) > 5;"
        }
      ]
    },

    "2_automated_responses": {
      "description": "Automated security responses to threats",
      "triggers": [
        {
          "name": "auto_block_suspicious_ip",
          "sql": "CREATE OR REPLACE FUNCTION public.auto_block_suspicious_ip() RETURNS TRIGGER AS $$ BEGIN IF NEW.severity = 'critical' THEN INSERT INTO public.rate_limits (identifier, identifier_type, action, blocked_until, block_reason) VALUES (NEW.ip_address::TEXT, 'ip', 'all_actions', CURRENT_TIMESTAMP + INTERVAL '24 hours', 'Automated block: critical security event') ON CONFLICT (identifier, identifier_type, action) DO UPDATE SET blocked_until = GREATEST(rate_limits.blocked_until, EXCLUDED.blocked_until); END IF; RETURN NEW; END; $$ LANGUAGE plpgsql;"
        }
      ]
    }
  },

  "implementation_notes": {
    "critical_requirements": [
      "All OTP operations must use bcrypt with cost factor 12",
      "Rate limiting must be enforced at multiple levels (IP, device, user)",
      "All sensitive operations must be logged in audit_logs table",
      "RLS policies must prevent cross-user data access",
      "Swiss canton validation must be enforced for compliance"
    ],
    
    "performance_considerations": [
      "Use CONCURRENTLY for index creation in production",
      "Implement connection pooling for high-traffic endpoints",
      "Consider read replicas for audit log queries",
      "Batch cleanup operations during low-traffic periods"
    ],

    "testing_requirements": [
      "Unit tests for all security functions",
      "Integration tests for OTP generation and verification",
      "Load testing for rate limiting mechanisms",
      "Penetration testing for RLS policy effectiveness",
      "GDPR compliance validation tests"
    ],

    "deployment_checklist": [
      "Backup existing database before migration",
      "Test all functions in staging environment",
      "Verify RLS policies don't break existing functionality",
      "Validate audit logging captures all required events",
      "Confirm rate limiting doesn't impact legitimate users"
    ]
  },

  "deliverables": {
    "sql_files": [
      "012_security_schema_enhancements.sql",
      "013_security_functions.sql", 
      "014_enhanced_rls_policies.sql",
      "015_security_data_migration.sql"
    ],
    "documentation": [
      "Security implementation guide",
      "RLS policy documentation",
      "Monitoring and alerting setup",
      "GDPR compliance validation"
    ],
    "testing_artifacts": [
      "Security test suite",
      "Performance benchmarks",
      "Compliance validation reports"
    ]
  }
}