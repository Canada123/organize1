#### COMPLETE REPOSITORY ANALYSIS & ORGANIZATION SPECIFICATION

#### SCOPE: 2000+ REPOSITORIES REQUIRING DEEP CONTENT ANALYSIS

#### CRITICAL REQUIREMENT: MUST READ FILE CONTENTS, NOT NAMES

#### FILE TYPES TO ANALYZE - COMPREHENSIVE LIST

##### Programming Languages
- Python: .py, .pyw, .pyx, .pyd, .ipynb
- JavaScript: .js, .mjs, .cjs, .jsx
- TypeScript: .ts, .tsx, .d.ts
- Java: .java, .class, .jar
- C/C++: .c, .cpp, .cc, .cxx, .h, .hpp, .hxx
- C#: .cs, .csx
- Go: .go
- Rust: .rs, .rlib
- Ruby: .rb, .rbw, .rake, .gemspec
- PHP: .php, .phtml, .php3, .php4, .php5, .php7, .phps
- Swift: .swift
- Kotlin: .kt, .kts
- Scala: .scala, .sc
- R: .r, .R, .rmd, .Rmd
- Julia: .jl
- Perl: .pl, .pm, .t, .pod
- Lua: .lua
- Haskell: .hs, .lhs
- Clojure: .clj, .cljs, .cljc, .edn
- Erlang: .erl, .hrl
- Elixir: .ex, .exs
- F#: .fs, .fsi, .fsx
- OCaml: .ml, .mli
- Nim: .nim, .nims
- Crystal: .cr
- Dart: .dart
- Groovy: .groovy, .gvy, .gy, .gsh

##### Logic & Knowledge Representation
- Prolog: .pl, .pro, .prolog, .P **(CRITICAL - YOU HAVE MANY OF THESE)**
- Facts and rules: fact, rule, predicate, clause, unification
- Horn clauses: horn clause, definite clause, goal
- Backtracking: backtrack, choice point, cut operator
- DCG: definite clause grammar, DCG, phrase
- Constraint solving: CLP, constraint, domain, labeling
- CLIPS: .clp
- Datalog: .dl, .datalog
- Answer Set Programming: .lp, .asp
- STRIPS: .strips, .pddl
- Lisp: .lisp, .lsp, .cl, .fasl
- Scheme: .scm, .ss
- Racket: .rkt, .rktl, .rktd

##### Ontology & Semantic Web
- OWL: .owl, .owx
- RDF: .rdf, .rdfs
- Turtle: .ttl
- N-Triples: .nt
- N-Quads: .nq
- N3: .n3
- JSON-LD: .jsonld
- SPARQL: .rq, .sparql
- SHACL: .shacl
- SKOS: .skos
- OBO: .obo

##### Data Formats
- JSON: .json, .geojson, .topojson, .json5
- XML: .xml, .xsd, .xsl, .xslt, .dtd
- YAML: .yaml, .yml
- TOML: .toml
- INI: .ini, .cfg, .conf, .config
- CSV: .csv
- TSV: .tsv, .tab
- Parquet: .parquet
- Avro: .avro
- Protocol Buffers: .proto
- MessagePack: .msgpack
- BSON: .bson
- HDF5: .h5, .hdf5
- NetCDF: .nc, .nc4
- SQLite: .sqlite, .sqlite3, .db
- LevelDB: .ldb
- Excel: .xlsx, .xls, .xlsm
- ODS: .ods

##### Markup & Documentation
- Markdown: .md, .markdown, .mdown, .mkdn, .mkd
- reStructuredText: .rst, .rest
- AsciiDoc: .adoc, .asciidoc, .asc
- Textile: .textile
- LaTeX: .tex, .latex, .ltx
- HTML: .html, .htm, .xhtml
- CSS: .css, .scss, .sass, .less, .styl
- Org-mode: .org
- POD: .pod
- NROFF: .man, .roff, .nroff
- Texinfo: .texi, .texinfo
- DocBook: .dbk

##### Database & Query Languages
- SQL: .sql, .ddl, .dml
- PostgreSQL: .pgsql
- MySQL: .mysql
- MongoDB Query: .mongodb
- CQL (Cassandra): .cql
- Cypher (Neo4j): .cypher
- GraphQL: .graphql, .gql
- Gremlin: .gremlin

##### Configuration & Build Files
- Make: Makefile, .mk, GNUmakefile
- CMake: CMakeLists.txt, .cmake
- Gradle: .gradle, gradle.properties
- Maven: pom.xml
- Ant: build.xml
- Bazel: BUILD, .bzl, WORKSPACE
- NPM: package.json, package-lock.json
- Yarn: yarn.lock
- Pipenv: Pipfile, Pipfile.lock
- Poetry: pyproject.toml, poetry.lock
- Cargo: Cargo.toml, Cargo.lock
- Go Modules: go.mod, go.sum
- Docker: Dockerfile, docker-compose.yml
- Kubernetes: .k8s.yml, .kube.yml
- Terraform: .tf, .tfvars
- Ansible: .ansible.yml, playbook.yml
- Vagrant: Vagrantfile
- CircleCI: .circleci/config.yml
- Travis: .travis.yml
- GitHub Actions: .github/workflows/*.yml
- GitLab CI: .gitlab-ci.yml
- Jenkins: Jenkinsfile

##### Game Development Files
- Unity: .unity, .prefab, .asset, .meta
- Unreal: .uasset, .umap, .upk
- Godot: .tscn, .tres, .godot
- GameMaker: .gml, .yyp, .yy
- RPG Maker: .rxdata, .rvdata, .rvdata2
- Ren'Py: .rpy, .rpyc
- Twine: .tw, .twee, .tw2
- Ink: .ink
- YarnSpinner: .yarn
- ChoiceScript: .txt (with *choice patterns)

#### REPOSITORY CATEGORIES - DETAILED TAXONOMY

##### DOCUMENT CREATION & GENERATION
Keywords to detect:
- PDF generation: pdf, pdfkit, reportlab, jspdf, pdfmake, wkhtmltopdf
- Document builders: docx, python-docx, document builder, report generator
- Markdown generation: markdown generator, md builder, kramdown, marked
- HTML generation: html generator, template engine, static site generator
- LaTeX generation: latex, tex generator, document class, tikz
- Spreadsheet creation: xlsx, excel generator, openpyxl, xlsxwriter
- Presentation creation: pptx, powerpoint generator, reveal.js, impress.js
- Report builders: jasper, crystal reports, report builder, reporting tool
- Invoice/Receipt: invoice generator, receipt builder, billing document
- Resume/CV: resume builder, cv generator, career document
- Certificate generator: certificate creator, award generator, diploma
- Form generator: form builder, pdf form, fillable document
- Template systems: template, boilerplate, document template
- Mail merge: mail merge, bulk document, personalization
- Documentation: sphinx, mkdocs, doxygen, javadoc, rustdoc

##### PARSING & LANGUAGE PROCESSING
Keywords to detect:
- Tokenization: tokenize, lexer, lexical, scanner, lex, flex
- Parsing: parse, parser, grammar, syntax, yacc, bison, antlr, peg, pegjs
- AST: ast, abstract syntax tree, syntax tree, parse tree, cst
- Grammar types: bnf, ebnf, abnf, context-free, regular expression
- Parser types: recursive descent, lr, lalr, ll, packrat, earley
- Language processing: compiler, interpreter, transpiler, source-to-source
- Pattern matching: regex, regexp, pattern, match, find, search
- Natural language: nlp, pos tagging, lemmatization, stemming, morphology
- Semantic analysis: semantic, type checking, symbol table, scope

##### GENERATION & SYNTHESIS
Keywords to detect:
- Code generation: codegen, generate, emit, output, produce
- Template engines: template, jinja, mustache, handlebars, ejs, pug
- Procedural generation: procedural, procgen, random generation, seed
- Text generation: markov, n-gram, language model, gpt, transformer
- Name generation: name generator, fantasy names, random names
- Content synthesis: synthesize, create, build, construct, compose
- Factory patterns: factory, builder, creator, instantiate
- Scaffolding: scaffold, boilerplate, skeleton, starter, init
- Data generation: mock, fake, fixture, seed data, test data

##### CODE INDEXING & SEARCH
Keywords to detect:
- Code indexers: ctags, etags, cscope, global, universal-ctags
- Symbol indexing: symbol index, symbol table, definition lookup
- Code search: ripgrep, ag, ack, grep, code search, searcher
- AST indexing: ast index, syntax tree index, semantic index
- Language servers: lsp, language server, langserver, completion
- Code browsers: source browser, code navigator, cross-reference
- Documentation index: doc index, api index, reference index
- Full-text search: lucene, elasticsearch, whoosh, xapian
- Semantic search: semantic code search, embedding, vector search
- Call graphs: call graph, dependency graph, reference graph
- Import analysis: import graph, dependency analysis, module graph
- Dead code: dead code detection, unused code, unreachable
- Code metrics: cyclomatic complexity, loc, sloc, code metrics

##### EXTRACTION & MINING
Keywords to detect:
- Web scraping: scrape, crawler, spider, beautifulsoup, scrapy, puppeteer
- Data extraction: extract, pull, retrieve, fetch, harvest
- Entity recognition: ner, entity extraction, named entity, entity recognition
- Information extraction: ie, relation extraction, fact extraction
- Pattern extraction: pattern mining, frequent itemset, association rule
- Text mining: text mining, document mining, content extraction
- Metadata extraction: metadata, exif, id3, file properties
- Table extraction: table extraction, tabula, camelot, pdf extraction
- API consumption: api client, rest client, graphql client, sdk

##### ANIMATION & GRAPHICS
Keywords to detect:
- Sprite animation: sprite, spritesheet, animation frame, atlas
- Skeletal animation: bone, rig, skeletal, inverse kinematics
- Particle systems: particle, emitter, particle effect
- Tweening: tween, easing, interpolation, lerp
- Animation curves: curve, bezier, spline, keyframe
- Physics animation: physics, rigid body, soft body, cloth
- Procedural animation: procedural, generated animation
- Motion capture: mocap, motion capture, bvh
- Character animation: walk cycle, idle animation, attack animation
- Visual effects: vfx, shader, effect, post-processing
- 2D graphics: canvas, 2d renderer, pixel art, tilemap
- 3D graphics: 3d, mesh, model, texture, material
- SVG manipulation: svg, vector graphics, path, drawing

##### WEB SCRAPING & DATA EXTRACTION  
Keywords to detect:
- Web scrapers: scrape, scraper, beautifulsoup, scrapy, puppeteer, playwright
- DOM parsing: dom parser, html parser, xml parser, cheerio, jsoup
- Browser automation: selenium, webdriver, headless browser, chrome headless
- API scraping: api scraper, endpoint extraction, rest scraper
- PDF extraction: pdf extract, tabula, camelot, pdfplumber, pymupdf
- Table extraction: table scraper, html table, data table extract
- Image extraction: image scraper, download images, media extraction
- Text extraction: text mining, content extraction, article extraction
- Link extraction: link scraper, url extraction, sitemap parser
- Form submission: form fill, form automation, post data
- Cookie handling: cookie, session, authentication scraping
- Rate limiting: throttle, delay, request limit, polite scraping
- Data cleaning: clean, normalize, dedupe, sanitize

##### VALIDATION & VERIFICATION
Keywords to detect:
- Schema validation: json schema, xml schema, xsd, validate, validator
- Type checking: type check, type safety, static typing, mypy, typescript
- Constraint checking: constraint, invariant, precondition, postcondition
- Data quality: data quality, data validation, integrity check
- Linting: lint, linter, eslint, pylint, rubocop, clippy
- Testing frameworks: unittest, pytest, jest, mocha, rspec, junit
- Assertion: assert, assertion, verify, ensure, check
- Contract programming: contract, design by contract, eiffel
- Formal verification: formal methods, model checking, theorem proving

##### ONTOLOGY & KNOWLEDGE REPRESENTATION
Keywords to detect:
- Ontology frameworks: owl, rdf, rdfs, sparql, protege, jena, owlapi
- Knowledge graphs: knowledge graph, semantic network, triple store
- Semantic web: semantic web, linked data, uri, iri, blank node
- Reasoning: reasoner, inference, pellet, hermit, fact++, racer
- Description logic: description logic, dl, abox, tbox, rbox
- Taxonomies: taxonomy, hierarchy, classification, categorization
- Controlled vocabularies: thesaurus, skos, controlled vocabulary
- Frame-based: frame, slot, filler, frame-based, minsky
- Concept mapping: concept map, cmap, mind map, knowledge map

##### DIALOGUE & CONVERSATION
Keywords to detect:
- Dialogue systems: dialogue, conversation, chat, chatbot, conversational
- Intent recognition: intent, intent classification, nlu, rasa, dialogflow
- Dialogue management: dialogue manager, dialogue state, dialogue policy
- Response generation: response generation, nlg, natural language generation
- Conversation trees: dialogue tree, conversation tree, branching dialogue
- Speech acts: speech act, utterance, illocution, perlocution
- Turn-taking: turn-taking, floor control, dialogue turn
- Chitchat: small talk, chitchat, social dialogue, phatic
- Task-oriented: task-oriented, goal-oriented, slot filling

##### NARRATIVE & STORYTELLING
Keywords to detect:
- Story generation: story generator, narrative generation, plot generation
- Story structures: three-act, hero's journey, monomyth, story arc
- Character development: character arc, character development, protagonist
- Plot elements: plot, subplot, conflict, resolution, climax, denouement
- World building: worldbuilding, setting, lore, backstory, history
- Interactive fiction: interactive fiction, if, twine, inform, choice-based
- Quest systems: quest, mission, objective, goal, task, adventure
- Narrative AI: narrative ai, story ai, drama manager, narrative planner
- Story grammars: story grammar, narrative grammar, propp, morphology

##### GAME MECHANICS & SYSTEMS
Keywords to detect:
- Combat systems: combat, battle, fight, damage, health, hp, armor
- Inventory: inventory, item, equipment, backpack, storage, container
- Crafting: craft, crafting, recipe, ingredient, combine, create
- Skills/Abilities: skill, ability, talent, perk, trait, attribute, stat
- Progression: level, xp, experience, progression, advancement, unlock
- Economy: currency, money, gold, economy, trade, market, shop
- Loot: loot, drop, reward, treasure, rng, random, probability
- Character systems: character, avatar, player, npc, stats, build
- Magic/Spells: spell, magic, mana, cast, cooldown, ability

##### AI & MACHINE LEARNING
Keywords to detect:
- Neural networks: neural network, deep learning, tensorflow, pytorch, keras
- NLP models: bert, gpt, transformer, word2vec, glove, fasttext
- Computer vision: cv, computer vision, opencv, image recognition, yolo
- Reinforcement learning: reinforcement learning, rl, q-learning, dqn
- Classification: classifier, classification, svm, decision tree, random forest
- Clustering: clustering, kmeans, dbscan, hierarchical clustering
- Regression: regression, linear regression, logistic regression, glm
- Recommendation: recommendation, recommender, collaborative filtering
- Agent systems: agent, multi-agent, mas, autonomous agent, bdi

##### DATA TRANSFORMATION & ETL
Keywords to detect:
- ETL processes: etl, extract transform load, pipeline, data pipeline
- Data mapping: mapping, data mapping, field mapping, schema mapping
- Format conversion: convert, conversion, transform, translate, migrate
- Data cleaning: clean, cleaning, preprocessing, normalization, dedup
- Aggregation: aggregate, aggregation, rollup, summary, group by
- Stream processing: stream, streaming, kafka, flink, storm, kinesis
- Batch processing: batch, batch processing, spark, hadoop, mapreduce
- Data integration: integrate, integration, merge, join, combine
- Serialization: serialize, deserialize, marshal, unmarshal, pickle

##### TESTING & QUALITY ASSURANCE
Keywords to detect:
- Unit testing: unit test, unittest, test case, test suite, mock
- Integration testing: integration test, e2e, end-to-end, selenium
- Performance testing: performance, benchmark, load test, stress test
- Fuzzing: fuzz, fuzzing, fuzzer, afl, libfuzzer, property-based
- Coverage: coverage, code coverage, branch coverage, statement coverage
- Mutation testing: mutation testing, mutant, pit, mutmut
- Contract testing: contract test, pact, consumer-driven
- Snapshot testing: snapshot, snapshot testing, golden file
- BDD: bdd, behavior-driven, cucumber, gherkin, given-when-then

##### VISUALIZATION & UI
Keywords to detect:
- Data visualization: visualization, chart, graph, plot, d3, plotly
- Dashboards: dashboard, metric, kpi, monitoring, grafana, kibana
- Diagram generation: diagram, flowchart, uml, graphviz, mermaid
- Map visualization: map, geo, gis, leaflet, mapbox, cartography
- Network visualization: network graph, force layout, cytoscape, gephi
- 3D visualization: 3d, three.js, webgl, opengl, vulkan, unity
- UI frameworks: react, vue, angular, svelte, component, widget
- UI patterns: mvc, mvvm, mvp, flux, redux, state management
- Responsive design: responsive, mobile-first, breakpoint, flexbox, grid

##### DATABASE & PERSISTENCE
Keywords to detect:
- ORM: orm, object-relational, sqlalchemy, hibernate, sequelize
- Query builders: query builder, knex, query dsl, criteria api
- Migrations: migration, migrate, schema migration, flyway, liquibase
- Connection pooling: connection pool, pool, pooling, hikari, c3p0
- Caching: cache, caching, redis, memcached, hazelcast, ehcache
- NoSQL: nosql, document store, key-value, graph database, column family
- Time series: time series, tsdb, influxdb, prometheus, timescaledb
- Search engines: elasticsearch, solr, lucene, full-text search, inverted index
- Data warehousing: data warehouse, olap, cube, dimension, fact table

##### ACTUAL TOOLS YOU HAVE (NOT ENTERPRISE SLOP)
Keywords to detect:
- Document creators: document generator, pdf creator, report builder, markdown generator
- Code indexers: indexer, code search, symbol index, ctags, code browser
- Prolog files: .pl, .pro, .prolog, facts, rules, predicates, clauses
- Story generators: story, narrative, plot, scene, character generator
- Game item databases: items.json, weapons.json, armor.json, loot tables
- Dialogue systems: dialogue.json, conversation trees, npc dialogue
- Character sheets: character stats, attributes, skills, traits
- Spell systems: spells.json, magic systems, abilities, cooldowns
- Combat mechanics: damage calculation, combat formulas, battle systems
- Crafting systems: recipes.json, crafting rules, combinations
- Quest systems: quests.json, objectives, missions, tasks
- Name generators: names.json, fantasy names, place names
- Probability tools: dice rollers, RNG, loot probability, drop rates
- World builders: maps, locations, regions, world generation
- NPC generators: npc creator, personality generator, character builder
- Template systems: templates, boilerplate, scaffolding
- Extraction tools: scraper, parser, data extractor, web scraper
- Validation tools: validator, schema checker, rule validator
- Transform tools: converter, transformer, format converter
- Animation tools: animation, sprite, movement patterns
- UI creators: interface builder, form generator, dashboard creator
- Diagram tools: flowchart, graph generator, visualization
- Music/Audio: music generator, sound effects, audio tools
- Genetic algorithms: genetic, GA, evolution, fitness function
- Maze/Puzzle: maze generator, puzzle solver, pathfinding
- Card games: deck builder, card mechanics, TCG systems
- Board games: board game mechanics, grid systems, tile systems
- Economics: economy simulation, market mechanics, trading systems
- Weather systems: weather generation, climate simulation
- Time systems: calendar, day/night cycle, scheduling
- Relationship systems: relationship mechanics, faction systems
- Morality systems: alignment, karma, reputation, ethics
- Skill trees: talent trees, progression paths, unlocks
- Inventory management: bags, containers, weight limits
- Status effects: buffs, debuffs, conditions, ailments
- Resource management: hunger, thirst, stamina, energy
- Building systems: construction, base building, placement
- Survival mechanics: hunger, temperature, shelter
- Physics simulations: collision, gravity, movement
- Pathfinding: A*, navigation, movement AI
- Behavior trees: AI behaviors, decision trees, state machines
- Neural networks: ML models, training data, neural nets
- Data corpora: word lists, text collections, datasets
- Language tools: translation, localization, language packs
- Save systems: save/load, serialization, game state
- Networking: multiplayer, server, client, protocol
- Mod support: modding tools, plugin systems, extensions

NOT THESE:
- NO certificates, SSL, TLS, PKI 
- NO Docker, Kubernetes, CI/CD
- NO "Owners: unassigned" metadata
- NO UUID tracking garbage
- NO file count statistics
- NO "Last Updated" timestamps in files

#### ANALYSIS DEPTH REQUIREMENTS

##### Primary Analysis (EXTRACT WHAT IT DOES)
- What the repository ACTUALLY DOES (not file counts)
- Main functionality (parser/generator/game mechanic/etc)
- What problem it solves
- What data it contains (items, dialogue, names, etc)
- What it generates or creates
- What game system it implements
- Dependencies it actually uses (not every import)

##### What to ACTUALLY Look For (REMOVE THE SLOP)
- What gameplay mechanics it implements
- What narrative structures it contains  
- What data it provides (items, characters, dialogue)
- What problems it solves (parsing, generating, validating)
- What ontologies or schemas it defines
- What algorithms it uses
- What game systems it models
- What content it generates
- What it extracts or transforms
- NOT version control, NOT docker, NOT licenses, NOT build systems

##### Content Extraction (WHAT TO ACTUALLY EXTRACT)
- What the repo ACTUALLY DOES based on reading the code
- Core algorithms and logic patterns found in functions
- Data structures and schemas being used
- Input/output formats the code handles
- External APIs or services it connects to
- Game mechanics it implements (if game-related)
- Narrative structures it uses (if story-related)
- Ontology definitions (if knowledge representation)
- Dialogue patterns (if conversation system)
- Validation rules (if validator)
- Generation templates (if generator)
- Parse grammars (if parser)
- The ACTUAL PROBLEM it solves, not character counts

#### OUTPUT STRUCTURE

##### Database Tables

###### repositories
- repo_id (PRIMARY KEY)
- repo_name (TEXT NOT NULL)
- full_path (TEXT NOT NULL)
- scan_timestamp (DATETIME)
- total_files (INTEGER)
- total_size_bytes (INTEGER)
- primary_language (TEXT)
- primary_category (TEXT)
- has_tests (BOOLEAN)
- has_docs (BOOLEAN)
- has_config (BOOLEAN)
- has_data_files (BOOLEAN)
- readme_excerpt (TEXT)
- entry_point (TEXT)
- last_modified (DATETIME)

###### categories
- category_id (PRIMARY KEY)
- category_name (TEXT UNIQUE)
- parent_category (TEXT)
- description (TEXT)
- keyword_list (TEXT)
- color_code (TEXT)

###### repo_categories
- mapping_id (PRIMARY KEY)
- repo_id (FOREIGN KEY)
- category_id (FOREIGN KEY)
- confidence_score (FLOAT 0-1)
- matched_keywords (TEXT)
- file_evidence (TEXT)

###### file_analysis
- file_id (PRIMARY KEY)
- repo_id (FOREIGN KEY)
- file_path (TEXT)
- file_type (TEXT)
- file_size (INTEGER)
- line_count (INTEGER)
- language (TEXT)
- content_sample (TEXT LIMIT 1000)
- has_tests (BOOLEAN)
- import_count (INTEGER)
- function_count (INTEGER)
- class_count (INTEGER)

###### dependencies
- dependency_id (PRIMARY KEY)
- repo_id (FOREIGN KEY)
- dependency_name (TEXT)
- version_spec (TEXT)
- dependency_type (TEXT) -- npm, pip, gem, etc
- is_dev_dependency (BOOLEAN)

###### repo_relationships
- relationship_id (PRIMARY KEY)
- repo_a_id (FOREIGN KEY)
- repo_b_id (FOREIGN KEY)
- relationship_type (TEXT) -- similar, depends_on, extends, etc
- confidence (FLOAT)

#### TAGGING SYSTEM

##### macOS Finder Tags Required
- Apply color-coded tags based on primary category
- Multiple tags allowed per repository
- Tag naming: lowercase, hyphenated (e.g., "game-mechanics", "text-parser")
- Colors: 
  - Red: needs-attention, broken, deprecated
  - Orange: work-in-progress, incomplete
  - Yellow: data-files, resources, assets
  - Green: tested, production-ready, stable
  - Blue: utilities, tools, helpers
  - Purple: experimental, research, prototype
  - Gray: archived, legacy, reference

##### .tag File Format (in each repo)
```
CATEGORIES: parser, nlp, text-processing
LANGUAGES: python, javascript
TYPE: tool
STATUS: active
LAST_SCAN: 2024-01-15
CONFIDENCE: 0.85
KEYWORDS_MATCHED: tokenize, parse, ast, grammar
```

#### PERFORMANCE REQUIREMENTS
- Must handle 2000+ repositories
- Must not crash on encoding errors
- Must skip binary files
- Must handle nested directories up to 10 levels deep
- Must process repos in parallel (multiprocessing)
- Must save progress incrementally (not lose work on crash)
- Must be resumable (skip already-processed repos)
- Must generate progress reports every 100 repos

#### ERROR HANDLING
- Log all errors to error.log
- Continue processing on single repo failure
- Track repos that failed to scan
- Handle: permission denied, file not found, encoding errors
- Handle: corrupt files, circular symlinks, massive files (>100MB)
- Create quarantine list for problematic repos

#### WHAT SUCCESS LOOKS LIKE
- Every repo categorized by what it ACTUALLY DOES
- Can query: "Show all genetic algorithm implementations" 
- Can find: "All Prolog logic programs"
- Can identify: "All document generators"
- Can discover: "All web scrapers"
- Can list: "All game item databases"
- Can find: "All dialogue systems"
- Can identify: "All animation tools"
- Can group: "All name generators together"
- NO metadata pollution in files
- NO generic keywords added
- NO "Owners: unassigned" garbage
- NO UUID tracking
- Just clean categorization of what each tool DOES

#### DELIVERABLES
1. SQLite database file with all tables populated
2. Per-category text files (CATEGORY_*.txt)
3. Summary statistics file (summary.txt)
4. Error log (errors.log)
5. Unprocessed repos list (failed.txt)
6. Relationship graph (optional: relationships.json)
7. Full scan report (scan_report.md)

#### EXPLICITLY FORBIDDEN
- DO NOT analyze by folder/file names only
- DO NOT create generic business categories (mvp, product, management)
- DO NOT output only JSON files
- DO NOT count files without analyzing content
- DO NOT hardcode specific paths
- DO NOT skip reading file contents
- DO NOT create shallow categorization
- DO NOT ignore file types you don't recognize
- DO NOT stop on first error
- DO NOT lose progress if interrupted
- DO NOT add REPO-TRACKER metadata to files
- DO NOT add UUIDs to files
- DO NOT add "Owners: unassigned" garbage
- DO NOT add "Last Updated" timestamps
- DO NOT modify README files with metadata
- DO NOT create tracking comments in files
- DO NOT add file count statistics
- DO NOT focus on enterprise software patterns (Docker, K8s, CI/CD)
- DO NOT add security categories unless actually present
- DO NOT add generic keywords like "ai", "automation", "data"

#### Current State
- 2000+ repositories containing various tool types and data formats
- No systematic organization or categorization
- Previous 500+ scripts failed because they only analyzed folder/file names, not contents
- Need content-based analysis to identify what each repo actually does

#### File Types to Analyze
- JSON files (game data, corpora, schemas, configurations)
- Python files (.py scripts, .ipynb notebooks)
- Prolog files (.pl, .pro, .prolog)
- Ontology files (.owl, .n3, .ttl, .rdf)
- TypeScript/JavaScript (.ts, .js, .jsx, .tsx)
- Markdown files (.md documentation)
- YAML/YML configuration files
- HTML/CSS interface files
- SQL database schemas
- CSV/TSV data files
- XML data files
- Shell scripts (.sh, .bash)
- R scripts (.r, .rmd)
- Lua scripts
- C/C++ source files
- Java files
- Ruby files (.rb)
- Go files (.go)
- Rust files (.rs)

#### Repository Categories to Identify

##### Game Mechanics & Systems
- item-systems (inventory, crafting, loot tables)
- mutation-systems (character transformation, evolution)
- cascading-choice (decision trees, consequence chains)
- dream-psych (psychological mechanics, dream logic)
- director-mechanics (AI director, dynamic difficulty)
- reward-economy (currency, XP, progression systems)
- hidden-mechanics (background metrics, implicit choices)
- combat-systems (battle mechanics, damage calculation)
- skill-abilities (talent trees, ability systems)
- stats-attributes (character statistics, modifiers)
- balancing-tools (game balance calculators)
- dice-mechanics (RNG systems, probability tools)

##### Narrative & Content Generation
- narrative-generation (story generators, plot tools)
- dialogue-systems (conversation trees, NPC dialogue)
- quest-generation (mission creators, objective systems)
- worldbuilding-tools (location generators, lore tools)
- character-generation (NPC creators, personality systems)
- name-generators (character names, place names)
- description-generators (item descriptions, scene setting)
- poetry-rhyming (verse generators, rhyme tools)
- text-adventure (interactive fiction tools)

##### Data Processing & Analysis
- parsers (text parsing, syntax analysis, tokenizers)
- extractors (entity extraction, data mining, scraping)
- validators (schema validation, data verification)
- transformers (data transformation, format conversion)
- analyzers (sentiment analysis, content analysis)
- classifiers (categorization, tagging systems)
- indexers (search indexing, content indexing)

##### Knowledge Representation
- ontologies (OWL files, semantic web, knowledge graphs)
- prolog-systems (logic programming, rule engines)
- schema-definitions (JSON schema, XML schema, data models)
- taxonomies (classification systems, hierarchies)
- knowledge-bases (fact databases, rule sets)
- semantic-networks (concept maps, relationship graphs)

##### AI & Machine Learning
- nlp-tools (natural language processing)
- ml-models (machine learning implementations)
- neural-networks (deep learning systems)
- agent-systems (autonomous agents, multi-agent)
- behavior-trees (AI behavior modeling)
- decision-systems (decision support, recommendation)
- pattern-recognition (image recognition, pattern matching)

##### Social & Community Systems
- social-networks (relationship modeling, social graphs)
- voting-governance (decision making, consensus systems)
- reputation-systems (trust metrics, karma systems)
- collaboration-tools (team coordination, project management)
- communication-protocols (messaging systems, chat tools)

##### Cultural & Domain-Specific
- folklore-mythology (myth databases, cultural stories)
- archetypes (character archetypes, story patterns)
- cultural-data (traditions, customs, cultural elements)
- historical-data (timelines, historical events)
- linguistics (language data, etymology, translation)
- music-systems (music generation, rhythm tools)
- genetics-biology (genetic algorithms, biological models)

##### User Interface & Visualization
- ui-components (interface elements, widgets)
- diagram-tools (flowcharts, graph visualization)
- data-visualization (charts, graphs, dashboards)
- map-generation (terrain, dungeons, world maps)
- asset-managers (resource management, file organization)

##### Testing & Development Tools
- unit-testing (test frameworks, test generators)
- benchmarking (performance testing, optimization)
- debugging-tools (error tracking, logging systems)
- build-tools (compilation, packaging, deployment)
- documentation-generators (API docs, readme generators)
- code-analyzers (linting, code quality, metrics)

##### Business & Management
- task-management (todo lists, project tracking)
- accounting-finance (budget tools, economic models)
- marketing-analytics (growth tools, user analytics)
- planning-tools (scheduling, resource planning)

##### Specialized Databases & Corpora
- corpora-collections (word lists, text collections)
- game-databases (item databases, monster compendiums)
- reference-data (lookup tables, constants, enums)
- template-collections (document templates, code templates)

#### Required Functionality

##### Content Reading Requirements
- Must read ACTUAL FILE CONTENTS, not just filenames
- Parse multiple file types (.json, .py, .md, .yml, .owl, .pl, etc.)
- Handle encoding errors gracefully
- Skip binary files
- Ignore common non-content files (node_modules, .git, etc.)

##### Analysis Requirements
- Identify primary function of each repository
- Detect multiple categories per repo
- Find specific tool types (parser, generator, validator, etc.)
- Identify data formats and schemas used
- Detect programming languages and frameworks
- Find ontologies and knowledge representations

##### Output Requirements
- SQLite database with structured data
- Categories table (category_id, category_name, keywords)
- Repositories table (repo_id, repo_name, path, primary_category)
- Repo_categories junction table (repo_id, category_id, confidence_score)
- File_contents table (file_id, repo_id, file_type, sample_content)
- Extracted_features table (feature_id, repo_id, feature_type, feature_value)

##### Tagging Requirements
- Apply macOS Finder tags to folders
- Create .tag files in repo directories
- Generate category-specific text reports
- Create searchable index

#### Database Schema

```sql
-- Categories definition
CREATE TABLE categories (
    category_id INTEGER PRIMARY KEY,
    category_name TEXT NOT NULL,
    keywords TEXT
);

-- Repository information  
CREATE TABLE repositories (
    repo_id INTEGER PRIMARY KEY,
    repo_name TEXT NOT NULL,
    repo_path TEXT NOT NULL,
    what_it_does TEXT,  -- Plain description of functionality
    main_category TEXT,
    has_prolog BOOLEAN,
    has_game_data BOOLEAN,
    has_dialogue BOOLEAN,
    has_ontology BOOLEAN
);

-- Many-to-many relationship
CREATE TABLE repo_categories (
    repo_id INTEGER,
    category_id INTEGER,
    matched_keywords TEXT,  -- Which keywords triggered this category
    FOREIGN KEY(repo_id) REFERENCES repositories(repo_id),
    FOREIGN KEY(category_id) REFERENCES categories(category_id)
);

-- Actual functionality found
CREATE TABLE functionality (
    function_id INTEGER PRIMARY KEY,
    repo_id INTEGER,
    function_type TEXT,  -- parser, generator, validator, etc
    function_detail TEXT,  -- what specifically it parses/generates/etc
    FOREIGN KEY(repo_id) REFERENCES repositories(repo_id)
);
```

#### Keywords for Category Detection

##### Parser Keywords
- parse, parser, tokenize, lexer, grammar, syntax, ast, abstract syntax tree
- lex, yacc, antlr, peg, bnf, ebnf, recursive descent
- token, lexical analysis, syntactic analysis

##### Generator Keywords
- generate, generator, create, build, produce, synthesize
- template, boilerplate, scaffold, factory, builder pattern
- procedural generation, random generation

##### Extractor Keywords
- extract, extraction, scrape, scraper, mine, mining
- harvest, collect, gather, pull, retrieve
- entity extraction, information extraction

##### Validator Keywords
- validate, validator, verify, check, test, assert
- schema validation, constraint, rule, requirement
- lint, linter, type check, bounds check

##### Ontology Keywords
- ontology, semantic, rdf, owl, sparql, triple store
- knowledge graph, semantic web, linked data
- taxonomy, hierarchy, classification, categorization

##### Dialogue Keywords
- dialogue, conversation, chat, message, communication
- talk, speak, utterance, response, interaction
- npc dialogue, dialogue tree, conversation system

##### Narrative Keywords
- story, narrative, plot, scene, chapter, episode
- fiction, tale, adventure, quest, journey
- storytelling, narration, prose

#### Success Criteria
- All 2000+ repos scanned and categorized
- Each repo has at least one category assigned
- Database contains full content analysis
- Can query repos by functionality
- Can find all tools of specific type
- Can identify repos with specific capabilities
- No hardcoded paths in final solution
- Works with any directory structure

#### What NOT to Do
- Do not analyze by folder/file names only
- Do not create generic marketing categories 
- Do not output JSON files
- Do not count files without purpose
- Do not create categories like "mvp-validation" or "product-management"
- Do not strip detailed requirements to summaries
- Do not hardcode specific paths